# avgn-jt-inventory

## Description
Simple and basic inventory control system with an API-first approach powered by Spring Boot.

## General considerations
The API is based on Spring Data REST concepts of models and repositories as main source for data exposition over autogenerated endpoints using HTTP verbs as "triggers" for CRUD like operations. The other good abstraction provided by this Spring module is the focus on hyper media as the means to control state (HATEOAS approach) and the protocols HAL and ALPS to provide data and describe it accordingly. So the resulting API has a great degree of self documentation and discoverability itself. It also allows to decouple the API client implementation at great extent.

The project uses JPA for the data source abstraction and H2 database for simplicity (it could be changed for a more production ready one by simply adding the required dependency and configurations) and some example data is preloaded for testing purposes.

To provide paging, filtering and sorting capabilites the project depends on QueryDSL. Although further implementations and customization should be done to give a really production ready result. At the moment it only allows for default strategies to process queries given via URL parameters using GET requests.


## TODOs
 - Implement security controls and data access protection
 - Implement business logic to prevent elimination of data based on especific constraints
 - Properly document the API (beyond its self explanatory and standards based approach)
 - Add many more tests
 - Add more documentation within the code to classes and methods


## Extras
 - A HAL explorer is shipped to navigate and test the API. It's accessible via the "/api" endpoint (which is also the API root endpoint)
 - A rather clumpsy front-end is also shipped with the project. It is powered by MithrilJS and Picnicss for simplicity. It's still a work in progress with many parts to improve and develop. It follows a rather generic approach by attempting to reuse as much functionality as possible (DRY principle) and keep the front-end development process as thin as possible (no build chains, no node, no npm).